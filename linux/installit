#!/bin/bash -x
# Add -x to above line for more verbose output
#
# TriEmbed ESP32/Dialog FPGA Project
# Todo: Get a project name!!! Then this can be <name>tools
#
# Tool chain installation script
# version 0.03 pete@soper.us

# MIT License
#
# Copyright 2022 Peter James Soper
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated 
# documentation files (the "Software"), to deal in the
# Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, 
# distribute, sublicense, and/or sell copies of the
# Software, and to permit persons to whom the Software is 
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall
# be included in all copies or substantial portions of the 
# Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
# KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The pathname to the Espressif esp-idf tools. 
# NOTE WELL that the aardvrk, the-ant, and triembedtools repos
# will be placed along side esp-idf, not within esp-idf
# The default is installation in the user's home directory
# Todo rename thetools to triembedtools?
# NEED A NAME FOR THE WHOLE PROJECT!!!

targetdir=~

# The git branch label for the exact version of tools to
# install. If this variable does not match the branch of an
# existing esp-idf the script must be aborted because there
# is the likelihood that the submodules are not right.
# The v4.4 branch is the latest Espressif stable branch.
# the v5.0 branch is the bleeding edge branch that is used
# by the Arduino runtime. NOTE that the TriEmbed project is
# currently committed to the stable branch.

targetbranch="v4.4"

# This is a todo. Just use raw list for Ubuntu until later
# Uncomment ONE of these three variable assignments below enable the prerequsite package installation for your system
# Todo automate the OS detection
# Todo May have to use while for per package to avoid spewage
# Todo if idf version 5.0 install Python 3.10

# Ubuntu and Debian:

#getpackages="sudo apt-get install git wget flex bison gperf python3 python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0"

# CentOS 7 & 8:

#CentOS 7 is still supported but CentOS version 8 is recommended for a better user experience.

#getpackages="sudo yum -y update && sudo yum install git wget flex bison gperf python3 cmake ninja-build ccache dfu-util libusbx"

packages="git wget flex bison gperf python3 python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0"

#Arch:

#getpackages="sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb"

#NOTE:  CMake version 3.16 or newer is required for use with ESP-IDF. Run “tools/idf_tools.py install cmake” to install a suitable version if your OS version doesn’t have one.
#todo automate this

#### Do not change lines below here

# Detail proper usage of the script command and error exit

usage() {
  echo $1
  echo "usage: installit [ -targetdir <path> ] [ -branch <branch id> ]"
  exit 1
}

# Get a Y or y or N or n after a prompt. Return true if Y or
# y, false if N or n. Cannot escape until an acceptable 
# answer is input. Use ctrl-C to break out.
# Todo signal handler to ensure exit 1 with ctrl-C if we
# don't get this for free

getyes() {
  ans="y"
  while [ ans = "Y" ] || [ ans = "y" ] || [ ans = "N" ] || [ ans = "n" ] ; do
    echo "$1"
    read ans
    if [ $ans = "Y" ] || [ $ans = "y" ] ; then
      return 1
    elif [ $ans = "N" ] || [ $ans = "n" ] ; then
      return 0
    else
      echo "Answer MUST be Y, y, N, or n"
    fi
  done
}

# Output a fatal error message and error exit

fatal() {
  echo $1
  exit 1
}

# Brute force handling of option switches

if [ $# -gt 0 ] ; then
  switch=$1
  shift
  case $switch in
    -branch) if [ $# -lt 1 ] ; then usage "-branch with no branch label" ; fi
	     targetbranch=$1;
             $shift;
	     break;;
    -targetdir) if [ $# -lt 1 ] ; then usage "-targetdir with no directory path" ; fi
	     targetdir=$1;
 	     shift;
	     break;;
    *): usage "unknown option switch"
	     exit 1;
  esac
fi

if [ $# -gt 0 ] ; then
  switch=$1
  shift
  case $switch in
    -branch) if [ $# -lt 1 ] ; then usage "-branch with no branch label" ; fi
	     targetbranch=$1;
             $shift;
	     break;;
    -targetdir) if [ $# -lt 1 ] ; then usage "-targetdir with no directory path" ; fi
	     targetdir=$1;
	     shift;
	     break;;
    *) usage "unknown option switch"
	     exit 1;
  esac
fi

# Install the required packages
# Todo need to just point a finger at the packages that did
# not install properly

#if "$getpackages " -eq " " ] ; then
#  fatal "must uncomment one package install line"
#fi

#$getpackages >/tmp/log.$$ 2>&1
#if [ $? -ne 0 ] ; then
#  echo "package install did not complete"
#  echo "exiting with error status after dumping log"
#  cat /tmp/log.$$
#  rm /tmp/log.$$
#  fatal "package installation error"
#else
#  echo "PACKAGES SEEMED TO INSTALL"
#  exit 
#fi

for package in $packages ; do
  sudo apt-get install $package >/tmp/log.$$ 2>&1
  if [ $? -ne 0 ] ; then
    echo "package $package did not install properly:"
    cat /tmp/log.$$
    fatal "Could not install $package"
  fi
done

echo "Prerequisite packages installed"

rm /tmp/log.$$

# Is the directory present and not empty?

if [ ls -1qA "$targetdir"/esp-idf 2>/dev/null | grep -q . 2>/dev/null -eq 0 ] ; then 
  present=1
else
  present=0
fi

# If dir is present then qualify it. If user wants to bail
# then error exit

if [ $present -eq 1 ] ; then
  pushd "$targetdir"/esp-idf
  git branch | grep "$targetbranch" >/dev/null 2>&1
  if [ $? -eq 0 ] && [ -e "$targetdir"/esp-idf/.cloned ] && [ -e "$targetdir"/esp-idf/.submodules ] && "$targetdir/esp-idf/.prepped" ]; then
    if [ getyes "$targetdir/esp-idf is present and usable. Skip erasing and doing a new clone? use current repo? (Y/N)" ] ; then
      rm -rf "$targetdir"/esp-idf
      if [ $? -ne 0 ] ; then
	fatal "Could not erase "$targetdir"/esp-idf"
      else
	present = 0
      fi
    fi
  else
    echo "Adjust/save esp-idf and rerun this script"
    exit 1
  fi
  popd
fi

pushd "$targetdir"

if [ $present ] ; then
  # This is probably bogus and we just carry on
  fatal "Internal error 1"
else
  git clone https://github.com/espressif.com/esp-idf >/dev/null 2>&1
  if [ $? -eq 0 ] ; then
    cd esp-idf
    touch .cloned
    git submodule update --init --recursive >/dev/null 2>&1
    if [ $? -eq 0 ] ; then
      touch .submodules
    else
      echo "git submodule update --init --recursive failed"
      exit 1
    fi
  else
    echo "https://github.com/espressif.com/esp-idf failed"
    exit 1
  fi
fi
