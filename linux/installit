#!/bin/bash -x
# Add -x to above line for more verbose output
#
# TriEmbed ESP32/Dialog FPGA Project
#
# Tool chain installation script
# The expectation is that much of this will be put under
# ../common and sourced by the remainder of this script that
# specializes it with arguments to the common script but 
# discussion is needed as the WSL version takes shape and the
# Windows version is thought through (by Windows developers).

# IP hack goes in aardvark/src/api/project.js

# Bugs:
#  0) SSID, password not set in the-ant. Freaking sdkconfig? who knows.
#     but apsta/Kconfig* DOES have the specified SSID/password.
#     Praying we can fix this with menuconfig
#  1) The I2C SDA and SCL pins are hard-wired in the-ant/main/i2c.c (first function).
#     There are conditionally compiled definitions based on target ESP32 that need
#     to be corrected. But the ass-kicker is that for the m80 dev board the pin
#     assignments changed between versions 0.60 and 0.70. Users of the 0.60 boar
#     must manually force the needed pin numbers in i2c.c (will be there with 
#     comments) after the first part of this bug is fixed.
#     Partially fixed.
#  2) .envrc still not right
#  3) Use chip id to eliminate need for targetdevice? Depends on the device
#     being plugged in. Probably best to use both.
 
#
# Todo:
#  1) Should be able to detect and elide redundant package
#     installs and perhaps npm install and npm run build
#  2) Use esptool to get ESP32 type and the mac address
#  3) Executable code comes AFTER all the function declarations
#  4) Add a function to handle the tmp log and operation result idiom

# Bump this per push

version="0.19"

# Add your email here and append your name to the copyright list with commas

# pete@soper.us
# rob.mackie@gmail.com

# MIT License
#
# Copyright 2022 Peter James Soper
# Copyright 2022 Robert Andrew Mackie
#
# Permission is hereby granted, free of charge, to any person 
# obtaining a copy of this software and associated 
# documentation files (the "Software"), to deal in the
# Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, 
# distribute, sublicense, and/or sell copies of the
# Software, and to permit persons to whom the Software is 
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall
# be included in all copies or substantial portions of the 
# Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
# KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The target WIFI router SSID
# NOTICE: These strings will be in plain text in the-ant repo. They will be
# encrypted eventually but for the time being remove the-ant after flashing to
# maintain security.

targetSSID=""
targetpassword=""

c3board=0

# The default target ESP32 device

targetdevice="ESP32C3"

# The pathname to the Espressif esp-idf tools. 
# NOTE WELL that the aardvrk, the-ant, and triembedtools repos
# will be placed along side esp-idf, not within esp-idf
# The default is installation in the user's home directory
# Todo rename thetools to triembedtools?
# NEED A NAME FOR THE WHOLE PROJECT!!!

targetdir=~/

# The git branch label for the exact version of tools to
# install. If this variable does not match the branch of an
# existing esp-idf the script must be aborted because there
# is the likelihood that the submodules are not right.
# The v4.4 branch is the latest Espressif stable branch.
# the v5.0 branch is the bleeding edge branch that is used
# by the Arduino runtime. NOTE that the TriEmbed project is
# currently committed to the stable branch. Also note that
# the v5.0 branch is updated frequently, so it is not safe to
# assume it is stable and frequent git pull operations and
# submodule operations are needed: neither of which are done
# by this script.

targetbranch="v4.4"

# This is a todo. Just use raw list for Ubuntu until later
# Uncomment ONE of these three variable assignments below enable the prerequsite package installation for your system
# Todo automate the OS detection
# Todo May have to use while for per package to avoid spewage
# Todo if idf version 5.0 install Python 3.10

# Ubuntu and Debian:

# The nvm version
nodeversion="14"

#getpackages="sudo apt-get install git wget flex bison gperf python3 python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 direnv curl"

# CentOS 7 & 8:

#CentOS 7 is still supported but CentOS version 8 is recommended for a better user experience.

#getpackages="sudo yum -y update && sudo yum install git wget flex bison gperf python3 cmake ninja-build ccache dfu-util libusbx direnv curl"

packages="git wget flex bison gperf python3 python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 direnv curl"

#Arch:

#getpackages="sudo pacman -S --needed gcc git make flex bison gperf python cmake ninja ccache dfu-util libusb direnv"

#NOTE:  CMake version 3.16 or newer is required for use with ESP-IDF. Run “tools/idf_tools.py install cmake” to install a suitable version if your OS version doesn’t have one.
#todo automate this

#### Do not change lines below here

# No need for sudo if root
if [ $USER = "root" ] ; then
  SUDO=""
else
  SUDO="sudo"
fi

# Detail proper usage of the script command and error exit

usage() {
  echo $1
  echo "usage: installit WIFISSID WIFIpassword [ -targetdevice <ESP32 | ESP32C3 | ESP32S2> ] [ -targetdir <path> ] [ -branch <branch id> ] [ -c3board <60 | 70> ] [ -version ] [ -help ]"
  echo "default targetdir: $targetdir"
  echo "default branch: $targetbranch"
  echo "default device: $targetdevice"
  exit 1
}

help() {
  echo "ESP32, ESP32S3 and ESPC3 supported"
  echo "I2C pins as follows:"
  echo "ESP32: SDA 18 SCL 19"
  echo "ESP32S2: SDA 1 SCL 0"
  echo "ESP32C3: SDA 18 SCL 19 (m80 60 rev) SDA 1 SCL 0 (m80 70 rev)"
  usage ""
}

# Get a Y or y or N or n after a prompt. Return true if Y or
# y, false if N or n. Cannot escape until an acceptable 
# answer is input. Use ctrl-C to break out.
# Todo signal handler to ensure exit 1 with ctrl-C if we
# don't get this for free

getyes() {
  while [ 1 -eq 1 ] ; do
    echo "$1"
    read ans
    if [ $ans = "Y" ] || [ $ans = "y" ] ; then
      return 0
    elif [ $ans = "N" ] || [ $ans = "n" ] ; then
      return 1
    else
      echo "Answer MUST be Y, y, N, or n"
    fi
  done
}

# Output a fatal error message and error exit

fatal() {
  echo $1
  rm -f /tmp/log.$$
  exit 1
}

# Brute force handling of option switches

if [ $# -lt 2 ] ; then
  usage "insufficient arguments"
else
  targetSSID=$1
  shift
  targetpassword=$1
  shift
fi

while [ $# -ge 2 ] ; do
  switch=$1
  shift
  echo "The flag: $switch"
  echo "The value: $1"
  case $switch in

    -targetbranch)
         targetbranch=$1;
         shift;
#	     break;;
        ;;
    -targetdir)
         targetdir=$1;
 	     shift;
#	     break;;
        ;;
    -targetdevice)
         targetdevice=$1;
 	     shift;
#             if [ ! $targetdevice = "ESP32" && ! $targetdevice = "ESP32S2" &&
#                  ! $targetdevice = "ESP32C3" ] ; then
#               usage "unrecognized ESP32";
#             fi
#	     break;;
        ;;
    -c3board)
             c3board=$1;
             shift;
             if [ $c3board -ne 70 && $c3board -ne 60 ] ; then
               fatal "-c3board value must be either 60 or 70"
             fi
#             break;;
             echo "chosen board == $c3board was chosen"
            ;;
    -version)
         echo "version: $version";
	     exit 0;;
    -help)
        help;;
    *)
         usage "unknown option switch: $1";
	     exit 1;;
  esac
done

if [ $# -gt 0 ] ; then
  if [ $1 = "-version" ] ; then
    echo "version: $version"
    exit 0
  elif [ $1 = "-help" ] ; then
    help
  else
    usage "unknown command line option: $@"
  fi
fi

case $targetdevice in
  ESP32C3) if [ $c3board -eq 60 ] ; then
             targetsda=18;
             targetscl=19;
           elif [ $c3board -eq 70 ] ; then
             targetsda=1;
             targetscl=0;
           else
             fatal "unknown ESP32C3 board version number"
           fi;
           break;;
  ESP32)  targetsda=18;
          targetscl=19;
          break;;
  ESP32S2) targetsda=1;
           targetscl=0;
           break;;
  *) fatal "unknown targetdevice: $targetdevice";;
esac

echo "targetdir: $targetdir
echo "targetdevice: $targetdevice"
echo "targetbranch: $targetbranch"
echo "node version: $nodeversion"
echo "targetsda: $targetsda"
echo "targetscl: $targetscl"

# Install the required packages
# Todo need to just point a finger at the packages that did
# not install properly

#if "$getpackages " -eq " " ] ; then
#  fatal "must uncomment one package install line"
#fi

#$getpackages >/tmp/log.$$ 2>&1
#if [ $? -ne 0 ] ; then
#  Grep this to flag package names?
#  cat /tmp/log.$$
#  fatal "packages did not all install properly"
#else
#  echo "packages installed
#fi

echo "installing packages"

for package in $packages ; do
  $SUDO apt-get install -y $package >/tmp/log.$$ 2>&1
  if [ $? -ne 0 ] ; then
    cat /tmp/log.$$
    fatal "Could not install $package"
  fi
done
ls -la $targetdir/the-ant

echo "Prerequisite packages installed"

# Is the directory present and not empty?

if [ -d $targetdir/esp-idf ] ; then
  present=1
else
  present=0
fi
# If dir is present then qualify it. If user wants to bail
# then error exit

if [ $present -eq 1 ] ; then
  cd $targetdir/esp-idf
  git branch | grep $targetbranch >/dev/null
  if [ $? -eq 0 ] && [ -e $targetdir/esp-idf/.cloned ] && [ -e $targetdir/esp-idf/.submodules ] ; then
    getyes "$targetdir/esp-idf is present and usable. Skip erasing and doing a new clone? use current repo? (Y/N)"
    if [ $? -eq 0 ] ; then
      present=1
    else
      rm -rf $targetdir/esp-idf
      if [ $? -ne 0 ] ; then
	fatal "Could not erase $targetdir/esp-idf"
      else
	present=0
      fi
    fi
  else
    getyes "$targetdir/esp-idf is on the wrong branch: delete and recreate it? (y/n)"
    if [ $? -eq 0 ] ; then
      rm -rf $targetdir/esp-idf
      if [ $? -ne 0 ] ; then
	fatal "Could not erase $targetdir/esp-idf"
      else
	present=0
      fi
    fi
  fi  
fi

if [ $present -eq 0 ] ;then
  cd $targetdir
  echo "cloning esp-idf"
  git clone http://github.com/espressif/esp-idf.git >/tmp/log.$$ 2>&1
  if [ $? -ne 0 ] ; then
    cat /tmp/log.$$
    fatal "Could not clone espressif esp-idf repository"
  else
    cd esp-idf
    touch .cloned
    git branch $targetbranch
    echo "loading submodules: this takes longer than the repo clone, be patient"
    git submodule update --init --recursive >/tmp/log.$$ 2>&1
    if [ $? -ne 0 ] ; then
      cat /tmp/log.$$
      fatal "git submodule update --init --recursive failed"
    else
      touch .submodules
    fi
    ./install.sh >/tmp/log.$$
    if [ $? -ne 0 ] ; then
      cat /tmp/log.$$
      fatal "esp-idf/intall.sh failed"
    fi

    # install source of export.sh in esp-idf/examples so power users can have 
    # multiple esp-idf dirs with different branches

    echo ". $targetdir/esp-idf/export.sh >/dev/null 2>&1" >$targetdir/esp-idf/examples/.envrc
    cd $targetdir/esp-idf/examples
    direnv allow
  fi
fi

echo "valid esp-idf repo"

for repo in aardvark the-ant ; do
  cd $targetdir
  if [ -d $targetdir/$repo ] ; then
    echo "pull on $repo"
    cd $targetdir/$repo
    git pull >/tmp/log.$$
    if [ $? -ne 0 ] ; then
      cat /tmp/log.$$
      fatal "could not update existing $repo repo"
    fi
  else
    echo "clone of $repo"
    git clone http://github.com/triembed/$repo.git >/tmp/log.$$ 2>&1
    if [ $? -ne 0 ] ; then
      cat log.$$
      fatal "could not clone $repo"
    fi
  fi
done

echo "aardvark and the-ant repos are present and up to date"

# setting up direnv to automatically run IDF export.sh and steer node version
# when the-ant is cd'd to.

if [ ! -f $targetdir/the-ant/.envrc ] ; then
  echo ". $targetdir/esp-idf/export.sh >/dev/null 2>&1" >$targetdir/the-ant/.envrc
  echo ". $targetdir/.nvm/nvm.sh use $nodeversion" >>$targetdir/the-ant/.envrc
  cd $targetdir/the-ant
  direnv allow
fi

# Adding direnv hook to .bashrc

grep "direnv hook bash" ~/.bashrc
if [ $? -ne 0 ] ; then
  echo 'eval "$(direnv hook bash)"' >>~/.bashrc
  if [ $? -ne 0 ] ; then
    fail "could not edit ~/.bashrc"
  fi
fi

if [ ! -d $HOME/.nvm ] ; then
  echo "installing nvm"
  curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh 2>/dev/null | bash >/tmp/log.$$ 2>&1
  if [ $? -ne 0 ] ; then
    cat /tmp/log.$$
    fatal "nvm could not be installed"
  fi
fi

. ~/.bashrc >/dev/null 2>&1

export NVM_DIR=$HOME/.nvm
source $NVM_DIR/nvm.sh >/dev/null 2>&1
echo "install node version $nodeversion"
nvm install $nodeversion >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not install nvm version $nodeversion"
fi

cd $targetdir/aardvark
echo "installing npm in aardvark"
npm install >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not intall npm in aardvark"
fi

echo "building npm in aardvark"
npm run build >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not npm run build in aardvark"
fi
  
cd $targetdir/the-ant/ant
echo "installing npm in the-ant"
npm install >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not intall npm in the-ant/ant"
fi
  
echo "building npm in the-ant"
npm run build >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not npm run build in the-ant"
fi

echo "idf set-target and Kconfig edits"

# Edit main/Kconfig.projbuild for SSID, password, SDA and SCL pins

cd $targetdir/the-ant/components/apsta
sed -e"s/.*dlink-018E.*$/                default $targetSSID/" Kconfig.projbuild >/tmp/tmp1.$$
sed -e"s/.*qwerty.*$/                default $targetpassword/" /tmp/tmp1.$$ >Kconfig.projbuild

cd $targetdir/the-ant/main
sed -e"s/.*TARGETSDA.*$/                default $targetsda/" Kconfig.projbuild >/tmp/tmp1.$$
sed -e"s/.*TARGETSCL.*$/                default $targetscl/" /tmp/tmp1.$$ >Kconfig.projbuild

. $targetdir/esp-idf/export.sh >/dev/null 2>&1

cd $targetdir/the-ant
idf.py set-target $targetdevice >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not do idf.py set-target"
fi

cd $targetdir/the-ant
rm -rf build
rm -rf ant/dist/js/*.map

echo "idf build of the-ant"
cd $targetdir/the-ant
idf.py build >/tmp/log.$$ 2>&1
if [ $? -ne 0 ] ; then
  cat /tmp/log.$$
  fatal "could not do idf.py build in the-ant"
fi

echo "installation complete"
echo "To use the IDF in arbitrary places add this line to ~/.bashrc:"
echo ". $targetdir/esp-idf/export.sh" >/dev/null 2>&1
echo "Now ready to enter $targetdir/aardvark and enter 'npm run serve'"
echo "Then point your browser to http://localhost:8080"
echo "Then cd to $targetdir/the-ant and enter 'idf.py flash'"
echo "Then enter 'idf.py monitor' (use cntrl ] to break out of monitor)"

rm -f log.$$

exit 0
